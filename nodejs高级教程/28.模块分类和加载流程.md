```js
// 模块分类和加载流程
/* 
    ①内置模块(核心模块)：node源码编译时写入到二进制中

    ②文件模块(第三方模块、其他模块)：代码运行时，动态加载的

    ③加载流程:
        1.路径分析：依据标识符确定模块位置
        2.文件定位：确定目标模块中具体的文件以及文件类型
        3.编译执行：采用对应的方式完成文件的编译执行

    ④路径分析之标识符
        1.路径标识符
        2.非路径标识符(如直接引入的核心模块API fs、path等)
        3.在查找模块时有一个模块路径的概念，可以理解为node在定位模块具体文件时的查找策略，表现形式是路径数组(在一个文件.js模块中可以用console.log(module.paths)来获取它的值)

    ⑤文件定位：
        1.假设项目下存在m1.js模块，导入时使用require('m1')不写后缀名的形式，那么查找文件时会以以下规则来补全后缀名后查找文件:
        m1.js -> m1.json ->m1.node
        2.如果以上的后缀名都没能拿到，那么Node就会认为自己拿到的是一个目录。会将这个目录当作包来处理，这个过程同样遵循CommonJS规范，它首先会在当前目录下查找package.json文件，使用JSON.parse()解析。从而去去除描述文件中main属性值。如果main属性值没有扩展名。则按照main.js->main.json->main.node的后缀名补全方式来查找。如果最后都找不到，则Node默认就会将index作为模块中的具体文件名称。去查找index.js->index.json->index.node
        它首先会在当前目录下寻找，然后再按照刚才提到的模块路径数组查找。如果查找不到，则报错。
    
    ⑥编译执行：
        1.通过定位拿到具体模块文件后，将该文件按照响应的方式进行编译和执行
        2.因为每个模块都是一个对象，当我们确定模块的文件位置后。就会先去创建一个新的对象， 再按照之前的路径将其载入，最终完成编译和执行。
        
    ⑦编译方式的不同:
        1.JS文件的编译执行： a.使用FS模块同步读入目标文件内容
                            b.对内容进行语法包装，生成可执行JS函数
                            c.调用函数时出传入exports、module、require等属性值
        2.JSON文件的编译执行： 将读取到的内容通过JSON.parse()解析。然后将结果返回给exports对象即可

    ⑧缓存优先原则
        作用：提高模块加载速度 
        1.在我们通过标识符确定了绝对路径之后，它首先会去缓存中查找是否存在我们想要的模块。如果有则返回模块。如果当前模块不存在，则经历一次完整加载流程。
        2.模块加载完成后，使用路径作为索引进行缓存。

    总结：
        路径分析：确定目标模块路径
        文件定位：确定目标模块中的具体文件
        编译执行：对模块内容进行编译，返回可用exports对象
*/
```